<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (monadlib.Monadlib.Stream)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">monadlib</a> &#x00BB; <a href="../index.html">Monadlib</a> &#x00BB; Stream</nav><header class="odoc-preamble"><h1>Module <code><span>Monadlib.Stream</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Streams supporting fair and unbounded search.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-StreamC" class="anchored"><a href="#module-type-StreamC" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-StreamC/index.html">StreamC</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The union of streams and collections.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Create a stream monad from an arbitrary inner monad, which computes the values discovered in each generation. This is pretty abstract, since we're not requiring that the inner monad is a <i>collection</i>. There is a constraint here, since we're strictly supposed to disallow a monad collection where order of elements matters. I think we can characterise this abstractly by saying that the plus operation on the inner monad must be commutative, but don't take my word for it!</p></div></div><div class="odoc-spec"><div class="spec module" id="module-MakeStreamC" class="anchored"><a href="#module-MakeStreamC" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="MakeStreamC/index.html">MakeStreamC</a></span><span> (<a href="MakeStreamC/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Here, we create a stream monad from a definite collection monad <a href="../Collection/module-type-T/index.html"><code>Collection.T</code></a>. The inner monad will be used to represent the generations in the stream. The order of elements in each generation should not matter, so you might want to use a set or a bag. If you want to live life on the edge, just remember that your code should not depend on the order of elements within generations (you can, of course, depend on the order that generations appear in the stream). You can enforce this constraint by performing, say, a sort on each generation.</p></div></div></div></body></html>